// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: attic/systems/controllers/qp_inverse_dynamics/id_controller_config.proto

#ifndef PROTOBUF_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED
#define PROTOBUF_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace drake {
namespace systems {
namespace controllers {
namespace qp_inverse_dynamics {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
void protobuf_AssignDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
void protobuf_ShutdownFile_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();

class Vec3;
class AccelerationConfig;
class ContactConfig;
class InverseDynamicsControllerConfig;

// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_AssignDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class AccelerationConfig : public ::google::protobuf::Message {
 public:
  AccelerationConfig();
  virtual ~AccelerationConfig();

  AccelerationConfig(const AccelerationConfig& from);

  inline AccelerationConfig& operator=(const AccelerationConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationConfig& default_instance();

  void Swap(AccelerationConfig* other);

  // implements Message ----------------------------------------------

  AccelerationConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccelerationConfig& from);
  void MergeFrom(const AccelerationConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double kp = 2;
  inline int kp_size() const;
  inline void clear_kp();
  static const int kKpFieldNumber = 2;
  inline double kp(int index) const;
  inline void set_kp(int index, double value);
  inline void add_kp(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      kp() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_kp();

  // repeated double kd = 3;
  inline int kd_size() const;
  inline void clear_kd();
  static const int kKdFieldNumber = 3;
  inline double kd(int index) const;
  inline void set_kd(int index, double value);
  inline void add_kd(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      kd() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_kd();

  // repeated double weight = 4;
  inline int weight_size() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 4;
  inline double weight(int index) const;
  inline void set_weight(int index, double value);
  inline void add_weight(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      weight() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_weight();

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField< double > kp_;
  ::google::protobuf::RepeatedField< double > kd_;
  ::google::protobuf::RepeatedField< double > weight_;
  friend void  protobuf_AddDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_AssignDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AccelerationConfig* default_instance_;
};
// -------------------------------------------------------------------

class ContactConfig : public ::google::protobuf::Message {
 public:
  ContactConfig();
  virtual ~ContactConfig();

  ContactConfig(const ContactConfig& from);

  inline ContactConfig& operator=(const ContactConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactConfig& default_instance();

  void Swap(ContactConfig* other);

  // implements Message ----------------------------------------------

  ContactConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactConfig& from);
  void MergeFrom(const ContactConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double weight = 2;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline double weight() const;
  inline void set_weight(double value);

  // optional double kd = 3;
  inline bool has_kd() const;
  inline void clear_kd();
  static const int kKdFieldNumber = 3;
  inline double kd() const;
  inline void set_kd(double value);

  // optional double mu = 4;
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 4;
  inline double mu() const;
  inline void set_mu(double value);

  // repeated .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_point = 5;
  inline int contact_point_size() const;
  inline void clear_contact_point();
  static const int kContactPointFieldNumber = 5;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& contact_point(int index) const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* mutable_contact_point(int index);
  inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* add_contact_point();
  inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >&
      contact_point() const;
  inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >*
      mutable_contact_point();

  // optional .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_normal = 6;
  inline bool has_contact_normal() const;
  inline void clear_contact_normal();
  static const int kContactNormalFieldNumber = 6;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& contact_normal() const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* mutable_contact_normal();
  inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* release_contact_normal();
  inline void set_allocated_contact_normal(::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal);

  // optional int32 num_basis_per_contact_point = 7;
  inline bool has_num_basis_per_contact_point() const;
  inline void clear_num_basis_per_contact_point();
  static const int kNumBasisPerContactPointFieldNumber = 7;
  inline ::google::protobuf::int32 num_basis_per_contact_point() const;
  inline void set_num_basis_per_contact_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.ContactConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_kd();
  inline void clear_has_kd();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_contact_normal();
  inline void clear_has_contact_normal();
  inline void set_has_num_basis_per_contact_point();
  inline void clear_has_num_basis_per_contact_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  double weight_;
  double kd_;
  double mu_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 > contact_point_;
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal_;
  ::google::protobuf::int32 num_basis_per_contact_point_;
  friend void  protobuf_AddDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_AssignDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ContactConfig* default_instance_;
};
// -------------------------------------------------------------------

class InverseDynamicsControllerConfig : public ::google::protobuf::Message {
 public:
  InverseDynamicsControllerConfig();
  virtual ~InverseDynamicsControllerConfig();

  InverseDynamicsControllerConfig(const InverseDynamicsControllerConfig& from);

  inline InverseDynamicsControllerConfig& operator=(const InverseDynamicsControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InverseDynamicsControllerConfig& default_instance();

  void Swap(InverseDynamicsControllerConfig* other);

  // implements Message ----------------------------------------------

  InverseDynamicsControllerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InverseDynamicsControllerConfig& from);
  void MergeFrom(const InverseDynamicsControllerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig centroidal_momentum = 2;
  inline bool has_centroidal_momentum() const;
  inline void clear_centroidal_momentum();
  static const int kCentroidalMomentumFieldNumber = 2;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& centroidal_momentum() const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_centroidal_momentum();
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_centroidal_momentum();
  inline void set_allocated_centroidal_momentum(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum);

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_body_motion = 3;
  inline bool has_default_body_motion() const;
  inline void clear_default_body_motion();
  static const int kDefaultBodyMotionFieldNumber = 3;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& default_body_motion() const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_default_body_motion();
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_default_body_motion();
  inline void set_allocated_default_body_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion);

  // repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig body_motion = 4;
  inline int body_motion_size() const;
  inline void clear_body_motion();
  static const int kBodyMotionFieldNumber = 4;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& body_motion(int index) const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_body_motion(int index);
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* add_body_motion();
  inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
      body_motion() const;
  inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
      mutable_body_motion();

  // optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_dof_motion = 5;
  inline bool has_default_dof_motion() const;
  inline void clear_default_dof_motion();
  static const int kDefaultDofMotionFieldNumber = 5;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& default_dof_motion() const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_default_dof_motion();
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* release_default_dof_motion();
  inline void set_allocated_default_dof_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion);

  // repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig dof_motion = 6;
  inline int dof_motion_size() const;
  inline void clear_dof_motion();
  static const int kDofMotionFieldNumber = 6;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& dof_motion(int index) const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* mutable_dof_motion(int index);
  inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* add_dof_motion();
  inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
      dof_motion() const;
  inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
      mutable_dof_motion();

  // optional .drake.systems.controllers.qp_inverse_dynamics.ContactConfig default_contact = 7;
  inline bool has_default_contact() const;
  inline void clear_default_contact();
  static const int kDefaultContactFieldNumber = 7;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& default_contact() const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* mutable_default_contact();
  inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* release_default_contact();
  inline void set_allocated_default_contact(::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact);

  // repeated .drake.systems.controllers.qp_inverse_dynamics.ContactConfig contact = 8;
  inline int contact_size() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 8;
  inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& contact(int index) const;
  inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* mutable_contact(int index);
  inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* add_contact();
  inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >&
      contact() const;
  inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >*
      mutable_contact();

  // optional double contact_force_basis_weight = 9;
  inline bool has_contact_force_basis_weight() const;
  inline void clear_contact_force_basis_weight();
  static const int kContactForceBasisWeightFieldNumber = 9;
  inline double contact_force_basis_weight() const;
  inline void set_contact_force_basis_weight(double value);

  // @@protoc_insertion_point(class_scope:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_centroidal_momentum();
  inline void clear_has_centroidal_momentum();
  inline void set_has_default_body_motion();
  inline void clear_has_default_body_motion();
  inline void set_has_default_dof_motion();
  inline void clear_has_default_dof_motion();
  inline void set_has_default_contact();
  inline void clear_has_default_contact();
  inline void set_has_contact_force_basis_weight();
  inline void clear_has_contact_force_basis_weight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig > body_motion_;
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig > dof_motion_;
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact_;
  ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig > contact_;
  double contact_force_basis_weight_;
  friend void  protobuf_AddDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_AssignDesc_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InverseDynamicsControllerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// optional double x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.x)
  return x_;
}
inline void Vec3::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.x)
}

// optional double y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.y)
  return y_;
}
inline void Vec3::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.y)
}

// optional double z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.Vec3.z)
  return z_;
}
inline void Vec3::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.Vec3.z)
}

// -------------------------------------------------------------------

// AccelerationConfig

// optional string name = 1;
inline bool AccelerationConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AccelerationConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
  return *name_;
}
inline void AccelerationConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
inline void AccelerationConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
inline void AccelerationConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}
inline ::std::string* AccelerationConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
  return name_;
}
inline ::std::string* AccelerationConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccelerationConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.name)
}

// repeated double kp = 2;
inline int AccelerationConfig::kp_size() const {
  return kp_.size();
}
inline void AccelerationConfig::clear_kp() {
  kp_.Clear();
}
inline double AccelerationConfig::kp(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return kp_.Get(index);
}
inline void AccelerationConfig::set_kp(int index, double value) {
  kp_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
}
inline void AccelerationConfig::add_kp(double value) {
  kp_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::kp() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return kp_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_kp() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kp)
  return &kp_;
}

// repeated double kd = 3;
inline int AccelerationConfig::kd_size() const {
  return kd_.size();
}
inline void AccelerationConfig::clear_kd() {
  kd_.Clear();
}
inline double AccelerationConfig::kd(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return kd_.Get(index);
}
inline void AccelerationConfig::set_kd(int index, double value) {
  kd_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
}
inline void AccelerationConfig::add_kd(double value) {
  kd_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::kd() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return kd_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_kd() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.kd)
  return &kd_;
}

// repeated double weight = 4;
inline int AccelerationConfig::weight_size() const {
  return weight_.size();
}
inline void AccelerationConfig::clear_weight() {
  weight_.Clear();
}
inline double AccelerationConfig::weight(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return weight_.Get(index);
}
inline void AccelerationConfig::set_weight(int index, double value) {
  weight_.Set(index, value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
}
inline void AccelerationConfig::add_weight(double value) {
  weight_.Add(value);
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
}
inline const ::google::protobuf::RepeatedField< double >&
AccelerationConfig::weight() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return weight_;
}
inline ::google::protobuf::RepeatedField< double >*
AccelerationConfig::mutable_weight() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig.weight)
  return &weight_;
}

// -------------------------------------------------------------------

// ContactConfig

// optional string name = 1;
inline bool ContactConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ContactConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
  return *name_;
}
inline void ContactConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
inline void ContactConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
inline void ContactConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}
inline ::std::string* ContactConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
  return name_;
}
inline ::std::string* ContactConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContactConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.name)
}

// optional double weight = 2;
inline bool ContactConfig::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactConfig::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactConfig::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactConfig::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double ContactConfig::weight() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.weight)
  return weight_;
}
inline void ContactConfig::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.weight)
}

// optional double kd = 3;
inline bool ContactConfig::has_kd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactConfig::set_has_kd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactConfig::clear_has_kd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactConfig::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline double ContactConfig::kd() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.kd)
  return kd_;
}
inline void ContactConfig::set_kd(double value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.kd)
}

// optional double mu = 4;
inline bool ContactConfig::has_mu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactConfig::set_has_mu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactConfig::clear_has_mu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactConfig::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline double ContactConfig::mu() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.mu)
  return mu_;
}
inline void ContactConfig::set_mu(double value) {
  set_has_mu();
  mu_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.mu)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_point = 5;
inline int ContactConfig::contact_point_size() const {
  return contact_point_.size();
}
inline void ContactConfig::clear_contact_point() {
  contact_point_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& ContactConfig::contact_point(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::mutable_contact_point(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::add_contact_point() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >&
ContactConfig::contact_point() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return contact_point_;
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::Vec3 >*
ContactConfig::mutable_contact_point() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_point)
  return &contact_point_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.Vec3 contact_normal = 6;
inline bool ContactConfig::has_contact_normal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactConfig::set_has_contact_normal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactConfig::clear_has_contact_normal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactConfig::clear_contact_normal() {
  if (contact_normal_ != NULL) contact_normal_->::drake::systems::controllers::qp_inverse_dynamics::Vec3::Clear();
  clear_has_contact_normal();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::Vec3& ContactConfig::contact_normal() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
  return contact_normal_ != NULL ? *contact_normal_ : *default_instance_->contact_normal_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::mutable_contact_normal() {
  set_has_contact_normal();
  if (contact_normal_ == NULL) contact_normal_ = new ::drake::systems::controllers::qp_inverse_dynamics::Vec3;
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
  return contact_normal_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::Vec3* ContactConfig::release_contact_normal() {
  clear_has_contact_normal();
  ::drake::systems::controllers::qp_inverse_dynamics::Vec3* temp = contact_normal_;
  contact_normal_ = NULL;
  return temp;
}
inline void ContactConfig::set_allocated_contact_normal(::drake::systems::controllers::qp_inverse_dynamics::Vec3* contact_normal) {
  delete contact_normal_;
  contact_normal_ = contact_normal;
  if (contact_normal) {
    set_has_contact_normal();
  } else {
    clear_has_contact_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.contact_normal)
}

// optional int32 num_basis_per_contact_point = 7;
inline bool ContactConfig::has_num_basis_per_contact_point() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactConfig::set_has_num_basis_per_contact_point() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactConfig::clear_has_num_basis_per_contact_point() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactConfig::clear_num_basis_per_contact_point() {
  num_basis_per_contact_point_ = 0;
  clear_has_num_basis_per_contact_point();
}
inline ::google::protobuf::int32 ContactConfig::num_basis_per_contact_point() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.num_basis_per_contact_point)
  return num_basis_per_contact_point_;
}
inline void ContactConfig::set_num_basis_per_contact_point(::google::protobuf::int32 value) {
  set_has_num_basis_per_contact_point();
  num_basis_per_contact_point_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.ContactConfig.num_basis_per_contact_point)
}

// -------------------------------------------------------------------

// InverseDynamicsControllerConfig

// optional string name = 1;
inline bool InverseDynamicsControllerConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InverseDynamicsControllerConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InverseDynamicsControllerConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InverseDynamicsControllerConfig::name() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
  return *name_;
}
inline void InverseDynamicsControllerConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
inline void InverseDynamicsControllerConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
inline void InverseDynamicsControllerConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}
inline ::std::string* InverseDynamicsControllerConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
  return name_;
}
inline ::std::string* InverseDynamicsControllerConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InverseDynamicsControllerConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.name)
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig centroidal_momentum = 2;
inline bool InverseDynamicsControllerConfig::has_centroidal_momentum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_centroidal_momentum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InverseDynamicsControllerConfig::clear_has_centroidal_momentum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InverseDynamicsControllerConfig::clear_centroidal_momentum() {
  if (centroidal_momentum_ != NULL) centroidal_momentum_->::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig::Clear();
  clear_has_centroidal_momentum();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::centroidal_momentum() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
  return centroidal_momentum_ != NULL ? *centroidal_momentum_ : *default_instance_->centroidal_momentum_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_centroidal_momentum() {
  set_has_centroidal_momentum();
  if (centroidal_momentum_ == NULL) centroidal_momentum_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
  return centroidal_momentum_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_centroidal_momentum() {
  clear_has_centroidal_momentum();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = centroidal_momentum_;
  centroidal_momentum_ = NULL;
  return temp;
}
inline void InverseDynamicsControllerConfig::set_allocated_centroidal_momentum(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* centroidal_momentum) {
  delete centroidal_momentum_;
  centroidal_momentum_ = centroidal_momentum;
  if (centroidal_momentum) {
    set_has_centroidal_momentum();
  } else {
    clear_has_centroidal_momentum();
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.centroidal_momentum)
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_body_motion = 3;
inline bool InverseDynamicsControllerConfig::has_default_body_motion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_body_motion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_body_motion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InverseDynamicsControllerConfig::clear_default_body_motion() {
  if (default_body_motion_ != NULL) default_body_motion_->::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig::Clear();
  clear_has_default_body_motion();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::default_body_motion() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
  return default_body_motion_ != NULL ? *default_body_motion_ : *default_instance_->default_body_motion_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_default_body_motion() {
  set_has_default_body_motion();
  if (default_body_motion_ == NULL) default_body_motion_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
  return default_body_motion_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_default_body_motion() {
  clear_has_default_body_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = default_body_motion_;
  default_body_motion_ = NULL;
  return temp;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_body_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_body_motion) {
  delete default_body_motion_;
  default_body_motion_ = default_body_motion;
  if (default_body_motion) {
    set_has_default_body_motion();
  } else {
    clear_has_default_body_motion();
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_body_motion)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig body_motion = 4;
inline int InverseDynamicsControllerConfig::body_motion_size() const {
  return body_motion_.size();
}
inline void InverseDynamicsControllerConfig::clear_body_motion() {
  body_motion_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::body_motion(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_body_motion(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::add_body_motion() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
InverseDynamicsControllerConfig::body_motion() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return body_motion_;
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
InverseDynamicsControllerConfig::mutable_body_motion() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.body_motion)
  return &body_motion_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig default_dof_motion = 5;
inline bool InverseDynamicsControllerConfig::has_default_dof_motion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_dof_motion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_dof_motion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InverseDynamicsControllerConfig::clear_default_dof_motion() {
  if (default_dof_motion_ != NULL) default_dof_motion_->::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig::Clear();
  clear_has_default_dof_motion();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::default_dof_motion() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
  return default_dof_motion_ != NULL ? *default_dof_motion_ : *default_instance_->default_dof_motion_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_default_dof_motion() {
  set_has_default_dof_motion();
  if (default_dof_motion_ == NULL) default_dof_motion_ = new ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig;
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
  return default_dof_motion_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::release_default_dof_motion() {
  clear_has_default_dof_motion();
  ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* temp = default_dof_motion_;
  default_dof_motion_ = NULL;
  return temp;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_dof_motion(::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* default_dof_motion) {
  delete default_dof_motion_;
  default_dof_motion_ = default_dof_motion;
  if (default_dof_motion) {
    set_has_default_dof_motion();
  } else {
    clear_has_default_dof_motion();
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_dof_motion)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.AccelerationConfig dof_motion = 6;
inline int InverseDynamicsControllerConfig::dof_motion_size() const {
  return dof_motion_.size();
}
inline void InverseDynamicsControllerConfig::clear_dof_motion() {
  dof_motion_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig& InverseDynamicsControllerConfig::dof_motion(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::mutable_dof_motion(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig* InverseDynamicsControllerConfig::add_dof_motion() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >&
InverseDynamicsControllerConfig::dof_motion() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return dof_motion_;
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::AccelerationConfig >*
InverseDynamicsControllerConfig::mutable_dof_motion() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.dof_motion)
  return &dof_motion_;
}

// optional .drake.systems.controllers.qp_inverse_dynamics.ContactConfig default_contact = 7;
inline bool InverseDynamicsControllerConfig::has_default_contact() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_default_contact() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InverseDynamicsControllerConfig::clear_has_default_contact() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InverseDynamicsControllerConfig::clear_default_contact() {
  if (default_contact_ != NULL) default_contact_->::drake::systems::controllers::qp_inverse_dynamics::ContactConfig::Clear();
  clear_has_default_contact();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& InverseDynamicsControllerConfig::default_contact() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
  return default_contact_ != NULL ? *default_contact_ : *default_instance_->default_contact_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::mutable_default_contact() {
  set_has_default_contact();
  if (default_contact_ == NULL) default_contact_ = new ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig;
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
  return default_contact_;
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::release_default_contact() {
  clear_has_default_contact();
  ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* temp = default_contact_;
  default_contact_ = NULL;
  return temp;
}
inline void InverseDynamicsControllerConfig::set_allocated_default_contact(::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* default_contact) {
  delete default_contact_;
  default_contact_ = default_contact;
  if (default_contact) {
    set_has_default_contact();
  } else {
    clear_has_default_contact();
  }
  // @@protoc_insertion_point(field_set_allocated:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.default_contact)
}

// repeated .drake.systems.controllers.qp_inverse_dynamics.ContactConfig contact = 8;
inline int InverseDynamicsControllerConfig::contact_size() const {
  return contact_.size();
}
inline void InverseDynamicsControllerConfig::clear_contact() {
  contact_.Clear();
}
inline const ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig& InverseDynamicsControllerConfig::contact(int index) const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Get(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::mutable_contact(int index) {
  // @@protoc_insertion_point(field_mutable:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Mutable(index);
}
inline ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig* InverseDynamicsControllerConfig::add_contact() {
  // @@protoc_insertion_point(field_add:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >&
InverseDynamicsControllerConfig::contact() const {
  // @@protoc_insertion_point(field_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return contact_;
}
inline ::google::protobuf::RepeatedPtrField< ::drake::systems::controllers::qp_inverse_dynamics::ContactConfig >*
InverseDynamicsControllerConfig::mutable_contact() {
  // @@protoc_insertion_point(field_mutable_list:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact)
  return &contact_;
}

// optional double contact_force_basis_weight = 9;
inline bool InverseDynamicsControllerConfig::has_contact_force_basis_weight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InverseDynamicsControllerConfig::set_has_contact_force_basis_weight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InverseDynamicsControllerConfig::clear_has_contact_force_basis_weight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InverseDynamicsControllerConfig::clear_contact_force_basis_weight() {
  contact_force_basis_weight_ = 0;
  clear_has_contact_force_basis_weight();
}
inline double InverseDynamicsControllerConfig::contact_force_basis_weight() const {
  // @@protoc_insertion_point(field_get:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact_force_basis_weight)
  return contact_force_basis_weight_;
}
inline void InverseDynamicsControllerConfig::set_contact_force_basis_weight(double value) {
  set_has_contact_force_basis_weight();
  contact_force_basis_weight_ = value;
  // @@protoc_insertion_point(field_set:drake.systems.controllers.qp_inverse_dynamics.InverseDynamicsControllerConfig.contact_force_basis_weight)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace qp_inverse_dynamics
}  // namespace controllers
}  // namespace systems
}  // namespace drake

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_attic_2fsystems_2fcontrollers_2fqp_5finverse_5fdynamics_2fid_5fcontroller_5fconfig_2eproto__INCLUDED
